# Rust 宏

## 宏的定义

```rust
// 宏的定义
macro_rules! greet {
    // 模式匹配
    ($name:expr) => {
        // 宏的展开
        println!("Hello, {}!", $name);
    };
}

fn main() {
    // 调用宏
    greet!("World");
}
```

- 模式匹配：宏通过模式匹配来匹配传递给宏的代码片段，模式是宏规则的左侧部分，用于捕获不同的代码结构。
- 规则：宏规则是一组由 $ 引导的模式和相应的展开代码，规则由分号分隔。
- 宏的展开：当宏被调用时，匹配的模式将被替换为相应的展开代码，展开代码是宏规则的右侧部分。

```rust
// 宏的定义
macro_rules! vec {
    // 基本情况，空的情况
    () => {
        Vec::new()
    };
    
    // 递归情况，带有元素的情况
    ($($element:expr),+ $(,)?) => {      // $(,)?) 用于处理末尾的逗号
        {
            let mut temp_vec = Vec::new();
            $(
                temp_vec.push($element);
            )+
            temp_vec
        }
    };
}

fn main() {
    // 调用宏
    let my_vec = vec![1, 2, 3];
    println!("{:?}", my_vec); // 输出: [1, 2, 3]

    let empty_vec = vec![];
    println!("{:?}", empty_vec); // 输出: []
}
```

## 过程宏（Procedural Macros）

- 派生宏（Derive Macros）：用于自动实现trait（比如Copy、Debug）的宏。
- 属性宏（Attribute Macros）：用于在声明上附加额外的元数据，如#[derive(Debug)]。

