# Rust 智能指针

## Box<T> 智能指针

- Box<T> 是 Rust 中最简单的智能指针之一，它允许在堆上分配一块内存，并将值存储在这个内存中。

- 由于 Rust 的所有权规则，使用 Box 可以在堆上创建具有已知大小的数据。

```rust
let b = Box::new(5);
println!("b = {}", b);
```

## Rc<T> 智能指针

- Rc<T>（引用计数指针）允许多个所有者共享数据，它使用引用计数来跟踪数据的所有者数量，并在所有者数量为零时释放数据。

```rust
use std::rc::Rc;

let data = Rc::new(5);
let data_clone = Rc::clone(&data);
```

## Arc<T> 智能指针

- Arc<T>（原子引用计数指针）与 Rc<T> 类似，但是可以安全地在多线程环境中共享数据，因为它使用原子操作来更新引用计数。

```rust
use std::sync::Arc;

let data = Arc::new(5);
let data_clone = Arc::clone(&data);
```

## RefCell<T> 智能指针

- RefCell<T> 允许在运行时检查借用规则，它使用内部可变性来提供了一种安全的内部可变性模式，允许在不可变引用的情况下修改数据。

```rust
use std::cell::RefCell;

let data = RefCell::new(5);
let mut borrowed_data = data.borrow_mut();
*borrowed_data = 10;
```

## Mutex<T> 智能指针

- Mutex<T> 是一个互斥锁，它保证了在任何时刻只有一个线程可以访问 Mutex 内部的数据。

```rust
use std::sync::Mutex;

let m = Mutex::new(5);
let mut data = m.lock().unwrap();
```

## RwLock<T> 智能指针

- RwLock<T> 是一种读取-写入锁，允许多个读取者同时访问数据，但在写入时是排他的。

```rust
use std::sync::RwLock;

let lock = RwLock::new(5);
let read_guard = lock.read().unwrap();
```

## Weak<T> 智能指针

- Weak<T> 是 Rc<T> 的非拥有智能指针，它不增加引用计数，用于解决循环引用问题。

```rust
use std::rc::{Rc, Weak};

let five = Rc::new(5);
let weak_five = Rc::downgrade(&five);
```

## 智能指针的生命周期管理

- 智能指针可以帮助管理数据的生命周期，当智能指针被销毁时，它们会自动释放内存，从而避免了内存泄漏和野指针的问题。

- 智能指针还允许在创建时指定特定的析构函数，以实现自定义的资源管理。

```rust
// 引入所需的依赖库
use std::rc::Rc;

// 定义一个结构体，用于存储数据
#[derive(Debug)]
struct Data {
    value: i32,
}

// 主函数
fn main() {
    // 创建一个 Rc 智能指针，共享数据
    let data = Rc::new(Data { value: 5 });

    // 克隆 Rc 智能指针，增加数据的引用计数
    let data_clone1 = Rc::clone(&data);
    let data_clone2 = Rc::clone(&data);

    // 输出数据的值和引用计数
    println!("Data value: {}", data.value);
    println!("Reference count: {}", Rc::strong_count(&data));

    // 打印克隆后的 Rc 智能指针
    println!("Data clone 1: {:?}", data_clone1);
    println!("Data clone 2: {:?}", data_clone2);
}
```