# Rust 异步编程 async/await

Rust 提供了多种工具和库来实现异步编程，包括 async 和 await 关键字、futures 和异步运行时（如 tokio、async-std 等）

- Future：Future 是 Rust 中表示异步操作的抽象。它是一个可能还没有完成的计算，将来某个时刻会返回一个值或一个错误。
- async/await：async 关键字用于定义一个异步函数，它返回一个 Future。await 关键字用于暂停当前 Future 的执行，直到它完成。

```rust
// 引入所需的依赖库
use tokio;
use tokio::time::{self, Duration};

// 异步函数，模拟异步任务
async fn async_task() -> u32 {
    // 模拟异步操作，等待 1 秒钟
    time::sleep(Duration::from_secs(1)).await;
    // 返回结果
    42
}

// 异步任务执行函数
async fn execute_async_task() {
    // 调用异步任务，并等待其完成
    let result = async_task().await;
    // 输出结果
    println!("Async task result: {}", result);
}

// 主函数
#[tokio::main]
async fn main() {
    println!("Start executing async task...");
    // 调用异步任务执行函数，并等待其完成
    execute_async_task().await;
    println!("Async task completed!");
}
```

tokio 库执行异步 HTTP 请求，并输出响应结果

```rust
// 引入所需的依赖库
use std::error::Error;
use tokio::runtime::Runtime;
use reqwest::get;

// 异步函数，用于执行 HTTP GET 请求并返回响应结果
async fn fetch_url(url: &str) -> Result<String, Box<dyn Error>> {
    // 使用 reqwest 发起异步 HTTP GET 请求
    let response = get(url).await?;
    let body = response.text().await?;
    Ok(body)
}

// 异步任务执行函数
async fn execute_async_task() -> Result<(), Box<dyn Error>> {
    // 发起异步 HTTP 请求
    let url = "https://jsonplaceholder.typicode.com/posts/1";
    let result = fetch_url(url).await?;
    // 输出响应结果
    println!("Response: {}", result);
    Ok(())
}

// 主函数
fn main() {
    // 创建异步运行时
    let rt = Runtime::new().unwrap();
    // 在异步运行时中执行异步任务
    let result = rt.block_on(execute_async_task());
    // 处理异步任务执行结果
    match result {
        Ok(_) => println!("Async task executed successfully!"),
        Err(e) => eprintln!("Error: {}", e),
    }
}
```

## 异步编程说明

### async 关键字

- async 关键字用于定义异步函数，即返回 Future 或 impl Future 类型的函数。异步函数执行时会返回一个未完成的 Future 对象，它表示一个尚未完成的计算或操作。

```rust
async fn hello() -> String {
    "Hello, world!".to_string()
}
```

### await 关键字

- await 表达式只能在异步函数或异步块中使用，它会暂停当前的异步函数执行，等待被等待的 Future 完成，然后继续执行后续的代码。

```rust
async fn print_hello() {
    let result = hello().await;
    println!("{}", result);
}
```

### 异步函数返回值

- 异步函数的返回值类型通常是 impl Future<Output = T>，其中 T 是异步操作的结果类型。由于异步函数的返回值是一个 Future，因此可以使用 .await 来等待异步操作的完成，并获取其结果。

```rust
async fn add(a: i32, b: i32) -> i32 {
    a + b
}
```

### 异步块

- 除了定义异步函数外，Rust 还提供了异步块的语法，可以在同步代码中使用异步操作。异步块由 async { } 构成，其中可以包含异步函数调用和 await 表达式。

```rust
async {
    let result1 = hello().await;
    let result2 = add(1, 2).await;
    println!("Result: {}, {}", result1, result2);
};
```

### 异步任务执行

- 在 Rust 中，异步任务通常需要在执行上下文中运行，可以使用 tokio::main、async-std 的 task::block_on 或 futures::executor::block_on 等函数来执行异步任务。这些函数会接受一个异步函数或异步块，并在当前线程或执行环境中执行它。

```rust
use async_std::task;

fn main() {
    task::block_on(print_hello());
}
```

### 错误处理

- await 后面跟一个 ? 操作符可以传播错误。如果 await 的 Future 完成时返回了一个错误，那么这个错误会被传播到调用者。

```rust
async fn my_async_function() -> Result<(), MyError> {
    some_async_operation().await?;
    // 如果 some_async_operation 出错，错误会被传播
}
```

### 异步 trait 方法

- Rust 允许为 trait 定义异步方法。可以为不同类型的对象定义异步操作。

```rust
trait MyAsyncTrait {
    async fn async_method(&self) -> Result<(), MyError>;
}

impl MyAsyncTrait for MyType {
    async fn async_method(&self) -> Result<(), MyError> {
        // 异步逻辑
    }
}
```

### 异步上下文

- 在 Rust 中，异步代码通常在异步运行时（如 Tokio 或 async-std）中执行。这些运行时提供了调度和执行异步任务的机制。

```rust
#[tokio::main]
async fn main() {
    some_async_operation().await;
}
```

### 异步宏

- Rust 提供了一些异步宏，如 tokio::spawn，用于在异步运行时中启动新的异步任务。

```rust
#[tokio::main]
async fn main() {
    let handle = tokio::spawn(async {
        // 异步逻辑
    });
    handle.await.unwrap();
}
```

### 异步 I/O

- Rust 的标准库提供了异步 I/O 操作，如 tokio::fs::File 和 async_std::fs::File。

```rust
use tokio::fs::File;
use tokio::io::{self, AsyncReadExt};

#[tokio::main]
async fn main() -> io::Result<()> {
    let mut file = File::open("file.txt").await?;
    let mut contents = String::new();
    file.read_to_string(&mut contents).await?;
    println!("Contents: {}", contents);
    Ok(())
}
```

### 异步通道

- Rust 的一些异步运行时提供了异步通道（如 tokio::sync::mpsc），允许在异步任务之间传递消息。

```rust
use tokio::sync::mpsc;
use tokio::spawn;

#[tokio::main]
async fn main() {
    let (tx, mut rx) = mpsc::channel(32);

    let child = spawn(async move {
        let response = "Hello, world!".to_string();
        tx.send(response).await.unwrap();
    });

    let response = rx.recv().await.unwrap();
    println!("Received: {}", response);

    child.await.unwrap();
}
```