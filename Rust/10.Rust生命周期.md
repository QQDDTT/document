# Rust 生命周期

- Rust 生命周期机制是与所有权机制同等重要的资源管理机制。

```rust
//  r 所引用的值已经在使用之前被释放
{
    let r;
    {
        let x = 5;
        r = &x;
    }
    println!("r: {}", r);
}
```

- 结构体中使用 String 而不用 &str

```rust
// 返回值引用可能会返回过期的引用
fn longer(s1: &str, s2: &str) -> &str {
    if s2.len() > s1.len() {
        s2
    } else {
        s1
    }
}
```

## 生命周期注释

- 生命周期注释是描述引用生命周期的办法。
- 虽然这样并不能够改变引用的生命周期，但可以在合适的地方声明两个引用的生命周期一致。
- 生命周期注释用单引号开头，跟着一个小写字母单词

```rust
&i32        // 常规引用
&'a i32     // 含有生命周期注释的引用
&'a mut i32 // 可变型含有生命周期注释的引用
```

```rust
// 生命周期注释改造 longer 函数
fn longer<'a>(s1: &'a str, s2: &'a str) -> &'a str {
    if s2.len() > s1.len() {
        s2
    } else {
        s1
    }
}
```

## 结构体中使用字符串切片引用

```rust
fn main() {
    struct Str<'a> {
        content: &'a str
    }
    let s = Str {
        content: "string_slice"
    };
    println!("s.content = {}", s.content);
}
```

## 静态生命周期

- 生命周期注释有一个特别的：'static 。
- 所有用双引号包括的字符串常量所代表的精确数据类型都是 &'static str 
- 'static 所表示的生命周期从程序运行开始到程序运行结束。

## 泛型 & 特性 & 生命周期 协同

```rust
use std::fmt::Display;

fn longest_with_an_announcement<'a, T>(x: &'a str, y: &'a str, ann: T) -> &'a str
    where T: Display
{
    println!("Announcement! {}", ann);
    if x.len() > y.len() {
        x
    } else {
        y
    }
}
```