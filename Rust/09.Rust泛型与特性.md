# Rust 泛型与特性

## 在函数中定义泛型

```rust
fn max(array: &[i32]) -> i32 {
    let mut max_index = 0;
    let mut i = 1;
    while i < array.len() {
        if array[i] > array[max_index] {
            max_index = i;
        }
        i += 1;
    }
    array[max_index]
}

fn main() {
    let a = [2, 4, 6, 3, 1];
    println!("max = {}", max(&a));
}
```

## 结构体与枚举类中的泛型

```rust
// 结构体
struct Point<T> {
    x: T,
    y: T
}

// 枚举类
enum Option<T> {
    Some(T),
    None,
}

enum Result<T, E> {
    Ok(T),
    Err(E),
}

// 注意，impl 关键字的后方必须有 <T>
impl<T> Point<T> {
    fn x(&self) -> &T {
        &self.x
    }
}

// 函数
fn main() {
    let p = Point { x: 1, y: 2 };
    println!("p.x = {}", p.x());
}
```

## 特性

- 特性与接口相同的地方在于它们都是一种行为规范，可以用于标识哪些类有哪些方法。

```rust
trait Descriptive {
    fn describe(&self) -> String;
}

// Descriptive 规定了实现者必需有 describe(&self) -> String 方法。

struct Person {
    name: String,
    age: u8
}

impl Descriptive for Person {
    fn describe(&self) -> String {
        format!("{} {}", self.name, self.age)
    }
}
```

## 默认特性

- 特性可以定义方法作为默认方法，因为是"默认"，所以对象既可以重新定义方法，也可以不重新定义方法使用默认的方法

```rust
trait Descriptive {
    fn describe(&self) -> String {
        String::from("[Object]")
    }
}

struct Person {
    name: String,
    age: u8
}

impl Descriptive for Person {
    fn describe(&self) -> String {
        format!("{} {}", self.name, self.age)
    }
}

fn main() {
    let cali = Person {
        name: String::from("Cali"),
        age: 24
    };
    println!("{}", cali.describe());
}
```

## 特性做参数

```rust
// 传递特性参数
fn output<T: Descriptive>(object: T) {
    println!("{}", object.describe());
}

// 有 Descriptive 特性规范的方法
fn output_two<T: Descriptive>(arg1: T, arg2: T) {
    println!("{}", arg1.describe());
    println!("{}", arg2.describe());
}

// 特性作类型表示时如果涉及多个特性，可以用 + 符号表示
fn notify(item: impl Summary + Display)
fn notify<T: Summary + Display>(item: T)
```

## 特性做返回值

```rust
fn person() -> impl Descriptive {
    Person {
        name: String::from("Cali"),
        age: 24
    }
}
```

## 有条件实现方法

- impl 功能十分强大，我们可以用它实现类的方法。
- 需要区分一下它所属的泛型已经实现的方法来决定它接下来该实现的方法。

```rust
struct A<T> {}

impl<T: B + C> A<T> {
    fn d(&self) {}
}
```