# 领域特定语言

## 一、DSL = Domain-Specific Language（领域特定语言）

### 定义（简明）：为特定问题域设计的编程/描述语言，用于用更高抽象、更简洁的语法直接表达该领域的概念和规则，而不是通用编程语言那样泛用。

### 常见例子

- SQL（数据库查询）——查询/操作关系数据。

- HTML/CSS（网页结构与样式）——标记和样式语言。

- 正则表达式（文本模式匹配）、Makefile、Terraform 的 HCL、构建脚本、DSL 用于配置 CI/CD、业务规则引擎的规则语言等。

### 分类（常见的维度）

1. 内部（嵌入式）DSL（Internal／Embedded）：用宿主通用语言的语法或 API 构造“看起来像”新语言的风格（例如用 Ruby 构建的 Rake、或在 Scala 内用 fluent API 写出的 DSL）。优点：实现简单、能复用宿主语言工具链。缺点：语法受宿主语言约束。

2. 外部（独立）DSL（External）：有自己专门的语法和解析器，通常需要单独的编辑器/解析器（如 SQL、正则表达式就是独立语法）。优点：更自由的语法设计，用户体验可以更好。缺点：实现成本更高（需解析、错误提示、工具支持）。

### 设计与实现方式（要点）

- 设计目标：先明确领域模型（domain concepts）、常见操作、用户（领域专家还是程序员）、可接受的语法复杂度。

- 实现方式：

    - 对于内部 DSL：设计流畅的 API、链式调用、运算符重载（若宿主语言支持）。

    - 对于外部 DSL：定义词法/语法（BNF/EBNF），用解析器生成器（ANTLR、PEG、lex/yacc），或者手写解析器；再实现解释器或编译器将 DSL 翻译为可执行代码或配置。

- 错误处理与工具支持：好的 DSL 需要良好错误提示、IDE/编辑器高亮与自动完成，这对用户体验非常关键。

### 优点

- 用更高层次、领域相关的术语直接表达意图 → 可读性、维护性强。

- 对领域专家友好（可让非程序员参与规则/配置编写）。

- 可以减少样板代码、提高生产率。

### 缺点 / 风险

- 额外维护成本（语法变更、解析器、工具链）。

- 学习成本（用户需学习新语法）。

- 过度的小众化会导致生态贫乏（调试/库支持弱）。

- 若实现不佳，会成为“胡乱包装”的配置语言，反而复杂。

## 二、明确目标与边界（Domain Modeling）

### 1️⃣ 明确领域

- DSL 是 为特定问题域（Domain）服务 的，所以必须先清楚：

    - 你要解决的是什么问题？

    - 你的目标用户是谁？（程序员？领域专家？普通配置人员？）

    - 他们最常见的任务是什么？

- 举例：

    - 数据处理 DSL → 操作数据集的过滤、聚合；

    - 规则引擎 DSL → 定义业务规则、触发条件；

    - AI 训练 DSL → 定义模型、优化器、数据源；

    - 构建系统 DSL（如 Gradle、Make）→ 定义任务、依赖关系。

### 2️⃣ 提炼领域概念

- 画出概念模型（Domain Model）或 UML 图，明确有哪些核心实体、动作、关系。

- 例如在“任务调度 DSL”中：

    - 实体：Job, Trigger, Schedule

    - 动作：run, delay, repeat, until

    - 关系：一个 Job 可以有多个 Trigger。

### 3️⃣ 控制边界

- DSL 不应变成“第二门通用语言”。

- 目标是让特定领域的描述更简单，而不是重新造 Python/Java。

## 三、设计语法（Syntax Design）
### 1️⃣ 决定类型：内部（Internal）或外部（External）

| 类型     | 特征                                 | 优点                 | 缺点                        | 典型例子              |
| ------ | ---------------------------------- | ------------------ | ------------------------- | ----------------- |
| 内部 DSL | 嵌入到现有语言中（用函数链式调用、Lambda、Builder 等） | 快速实现、可用宿主语言的调试和工具链 | 语法受限、难以真正自然               | Gradle（基于 Groovy） |
| 外部 DSL | 独立语法、独立解析                          | 语法自由、可读性好          | 要写 Lexer/Parser、IDE 支持成本高 | SQL、正则、GraphQL    |

### 2️⃣ 语法风格设计

- 尽量贴近用户熟悉的领域表达方式（如“英语式”规则）。

- 让 DSL “读起来像说明书，而不是代码”。

- 尽量保持一致性：

    - 命名规则一致（全部小写或驼峰）；

    - 操作符语义统一；

    - 参数顺序与领域逻辑一致。

### 3️⃣ 可读性优先于简短

- 不要追求极端的简洁而牺牲清晰度。

- 用冗余的小词（例如 “when”, “then”, “do”）反而能提升理解。

## 三、实现（Implementation）
### 1️⃣ 外部 DSL 实现流程

- 典型步骤如下：

```bash
源码 (.dsl)
   ↓
词法分析（Lexer）→ Token 流
   ↓
语法分析（Parser）→ 抽象语法树（AST）
   ↓
语义分析（Semantic Analysis）→ 检查语义正确性
   ↓
解释器 / 编译器
   ↓
执行或生成目标代码（Java、Python、SQL、字节码等）
```

### 可用工具：

- ANTLR / PEG.js / Lark / PLY / yacc / lex（用于语法分析）

- Visitor 模式处理 AST

- 解释器（Interpreter）模式 执行 DSL

- 若要编译，可生成中间表示（IR）

### 2️⃣ 内部 DSL 实现方式

- 设计流畅的 API：

```kotlin
task("build") {
    dependsOn("compile")
    doLast { println("Building...") }
}
```
或用构造器模式：

```python
with job("backup") as j:
    j.every("1h").run("copy /data /backup")
```

## 四、错误处理与调试支持

这是 DSL 成功与否的关键之一。

### 1️⃣ 语法错误提示

- 提供 清晰且领域相关的错误提示，而不是底层解析错误。

  ❌ “Unexpected token at line 5”

  ✅ “语句 repeat 需要一个循环条件 (at line 5)”

### 2️⃣ 语义错误检测

- 提前发现逻辑问题（如未定义变量、重复定义任务、非法依赖循环）。

- 可以通过 AST 语义分析阶段检测。

### 3️⃣ 调试与日志

- DSL 用户往往不是程序员。

- 提供：

    - “Dry-run”（只显示执行计划，不执行）

    - 详细日志（记录每一步语义动作）

## 五、可扩展性与维护
### 1️⃣ 模块化设计

- DSL 解释器要有插件机制：新增语法不必改动核心。

- 可通过注册模式（Registry）增加关键字或函数。

### 2️⃣ 向后兼容

- 新版本语法要兼容旧脚本，防止用户脚本失效。

### 3️⃣ 文档与示例

- 每个语法特性必须有一条“例句 + 效果”。

- 最好有 Playground 或 Web IDE。

## 六、实用建议（经验总结）

### ✅ 推荐实践

- 从 最小可用语法（MVP）开始，后续再扩展。

- 让 DSL 用户自己参与语法评审。

- 写大量测试（特别是解析器部分）。

- 提供 AST 可视化 工具，方便调试。

- 如果 DSL 生成代码或配置，提供 “–emit-code” 模式让用户查看生成结果。

### ❌ 常见陷阱

- 语法太复杂（和通用语言没区别）。

- 解析器逻辑耦合太深、难以扩展。

- 忽略错误提示和文档。

- 领域未建模清晰，导致 DSL 模糊不清。

## 七、一个简单的外部 DSL 示例（说明结构）

- 假设我们要设计一个 任务调度 DSL：

  语法设计

```dsl
job "backup" {
    every 1h
    do "copy /data /backup"
}

job "cleanup" {
    at "03:00"
    do "delete /tmp/*"
}
```



