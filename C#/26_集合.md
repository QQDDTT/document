# C# 集合（Collection）

**集合（Collection）类是专门用于数据存储和检索的一类类**

- 栈（Stack） —— 后进先出（LIFO）结构；
- 队列（Queue） —— 先进先出（FIFO）结构；
- 列表（List） —— 可动态扩展的有序序列；
- 哈希表（HashTable） —— 通过键值对快速查找数据。

## 各种集合类和它们的用法

| 类 | 描述和用法 |
| --- | --- |
| 动态数组（ArrayList） | 它代表了可被单独索引的对象的有序集合。<br>它基本上可以替代一个数组。但是，与数组不同的是，您可以使用索引在指定的位置添加和移除项目，动态数组会自动重新调整它的大小。它也允许在列表中进行动态内存分配、增加、搜索、排序各项。 |
| 哈希表（Hashtable） | 它使用键来访问集合中的元素。<br>当您使用键访问元素时，则使用哈希表，而且您可以识别一个有用的键值。哈希表中的每一项都有一个键/值对。键用于访问集合中的项目。 |
| 排序列表（SortedList） | 它可以使用键和索引来访问列表中的项。<br>排序列表是数组和哈希表的组合。它包含一个可使用键或索引访问各项的列表。如果您使用索引访问各项，则它是一个动态数组（ArrayList），如果您使用键访问各项，则它是一个哈希表（Hashtable）。集合中的各项总是按键值排序。 |
| 堆栈（Stack） | 它代表了一个后进先出的对象集合。<br>当您需要对各项进行后进先出的访问时，则使用堆栈。当您在列表中添加一项，称为推入元素，当您从列表中移除一项时，称为弹出元素。 |
| 队列（Queue） | 它代表了一个先进先出的对象集合。<br>当您需要对各项进行先进先出的访问时，则使用队列。当您在列表中添加一项，称为入队，当您从列表中移除一项时，称为出队。 |
| 点阵列（BitArray） | 它代表了一个使用值 1 和 0 来表示的二进制数组。<br>当您需要存储位，但是事先不知道位数时，则使用点阵列。您可以使用整型索引从点阵列集合中访问各项，索引从零开始。 |

## C# 动态数组（ArrayList）

```csharp
public class ArrayList : ICollection, IEnumerable, IList, ICloneable
```

### 实现接口：

- IList：支持按索引访问元素。
- ICollection：支持集合基本操作，如添加、删除和计数。
- IEnumerable：支持通过枚举器遍历元素。
- ICloneable：支持克隆 ArrayList。

## C# 哈希表（Hashtable）

```csharp
public class Hashtable : ICollection, IEnumerable, IDictionary, ICloneable, IDeserializationCallback, ISerializable;
public class Dictionary<TKey, TValue> : ICollection<KeyValuePair<TKey, TValue>>, IEnumerable<KeyValuePair<TKey, TValue>>, IEnumerable, IDictionary<TKey, TValue>, IReadOnlyCollection<KeyValuePair<TKey, TValue>>, IReadOnlyDictionary<TKey, TValue>, ICollection, IDictionary, IDeserializationCallback, ISerializable where TKey : notnull;
```
### 实现接口：
- ISerializable: 序列化

### 基本结构：

- 键（Key）：用于标识每个数据项，必须是唯一的，不能为 null。
- 值（Value）：键所对应的数据，可以为 null。

### 特点：

- 键值对存储：每个键都是唯一的，与一个值相关联。
- 哈希算法：通过键的哈希码定位数据存储位置，查找和插入操作的平均时间复杂度为 O(1)。
- 动态调整容量：当哈希表中元素数目超过容量时，表会动态扩展并重新分配存储。
- 无序存储：键值对的存储顺序与插入顺序无关，由哈希码决定。

## C# 排序列表（SortedList）

- 非泛型

```csharp
public class SortedList : ICollection, IEnumerable, IDictionary, ICloneable;
```

- 泛型

```csharp
public class SortedList<TKey, TValue> : ICollection<KeyValuePair<TKey, TValue>>, IEnumerable<KeyValuePair<TKey, TValue>>, IEnumerable, IDictionary<TKey, TValue>, IReadOnlyCollection<KeyValuePair<TKey, TValue>>, IReadOnlyDictionary<TKey, TValue>, ICollection, IDictionary where TKey : notnull;
```

### 特点:

- 自动排序：所有键都按照升序排序，无需手动调用排序方法。
- 键值对存储：每个键都唯一，与其关联的值可以重复。
- 动态调整容量：根据需要自动调整内部存储的大小。
- 索引访问：通过键或索引访问数据。
- 高效操作：检索、插入、删除的平均时间复杂度为 O(log n)。

## C# 堆栈（Stack）

- 非泛型 Stack

```csharp
public class Stack : ICollection, IEnumerable, ICloneable
```

- 泛型 Stack<T>

```csharp
public class Stack<T> : IEnumerable<T>, IEnumerable, IReadOnlyCollection<T>, ICollection
```

### Stack 特性：

- 后进先出：最后压入堆栈的元素最先弹出。
- 动态大小：堆栈的容量根据需要动态调整。
- 泛型支持：通过 Stack<T> 提供类型安全，避免类型转换错误。
- 非线程安全：默认 Stack 和 Stack<T> 都不是线程安全的。

### 常用函数

| 方法名称 | 返回类型 |	描述 |
| --- | --- | --- |
| Push(object item) | void | 将元素压入堆栈的顶部。 |
| Pop() | object | 移除并返回堆栈顶部的元素。 |
| Peek() | object |	返回堆栈顶部的元素，但不移除。 |
| Clear() |	void | 移除堆栈中的所有元素。 |

## C# 队列（Queue）

```csharp
public class Queue : ICollection, IEnumerable, ICloneable
```

### 特性

- 先进先出：最早加入队列的元素最先被移除。
- 动态大小：队列的容量会根据需要动态调整。
- 泛型支持：通过 Queue<T> 可以存储强类型的元素。
- 线程安全：Queue 本身不是线程安全的，但可以使用 ConcurrentQueue<T> 实现线程安全。

### 常用函数

| 方法名称 | 返回类型 |	描述 |
| --- | --- | --- |
| Enqueue(object item) | void |	将元素添加到队列的末尾。 |
| Dequeue() | object | 移除并返回队列开头的元素。 |
| Peek() | object |	返回队列开头的元素，但不移除。 |
| Clear() |	void | 移除队列中的所有元素。 |

## C# 点阵列（BitArray）

```csharp
public sealed class BitArray : ICollection, IEnumerable, ICloneable
```

| 方法名称 | 返回类型 |	描述 |
| --- | --- | --- |
| And(BitArray) | BitArray | 按位与操作，将两个 BitArray 对应位进行与运算，并返回结果。 |
| Or(BitArray) | BitArray |	按位或操作，将两个 BitArray 对应位进行或运算，并返回结果。 |
| Xor(BitArray) | BitArray | 按位异或操作，将两个 BitArray 对应位进行异或运算，并返回结果。 |
| Not() | BitArray | 按位取反操作，将 BitArray 的每个位取反，并返回结果。 |
| Set(int index, bool value) | void | 将指定索引处的位设置为指定值（true 或 false）。 |
| SetAll(bool value) | void | 将所有位设置为指定值（true 或 false）。 |
